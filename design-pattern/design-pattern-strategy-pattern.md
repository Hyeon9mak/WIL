# 디자인 패턴 - 전략 패턴
> 디자인 패턴은 코드가 아닌, 똑같은 문제를 마주치고 해결했던 선대 개발자들의 경험을 재사용하는 것이다.

전략 패턴은 결국 '변경이 자주 발생할 영역을 interface 로 구분하여, 차후 요구사항이 생길 때 Class 하나만 생성/관리 하면 되는 패턴' 이다.

## 상속(extends)을 이용하는 경우 생길 수 있는 문제점
- 모든 상속 구현체들이 같은 코드 변화에 영향을 받는다.
	- 인간은 모든 edge-case 와 미래 변화를 예측할 수 없다.
	- 공통 코드를 재활용 할 수 있다는 건 장점이지만, 너무 많아지면 이 공통 코드가 변경될 때 커다란 사이드이펙트를 만든다. 단점이 되기도 한다.
- 모든 상속 구현체들의 method 를 일일히 살펴보고, 상황에 따라 override 해야 한다.
	- 가령 `fly()` method 를 추가한 경우, 날면 안되는 오리가 날게 되는 문제가 생긴다.
	- `override "날지 않는다."`를 매번 하는 것도 곤욕.
- 단순히 상속 대신 interface 를 구현하도록 하는 것도 문제.
	- 공통 부분에 대한 변화가 생길 경우, 모든 구현체를 열어보며 확인해야한다.

## 디자인 원칙
- 애플리케이션에서 달라지는 부분을 찾고, 달리지지 않는 부분과 분리한다.
- 현실 세계에서 수 세기 이상 변하지 않았던 절대 불변의 진리를 이용하면 쉽다.
- 가령 Duck sub-class 들의 `swim()` 과 `fly()` 행위를 별도 interface 로 명세하고, 그 구현을 각기 별도 sub-class 로 진행한다.
	- 각 Duck sub-class 들은 생성 시점에 swim sub-class, fly sub-class 를 주입 받는다.
	- 이를 통해 Duck 과 swim, fly 간 계층 분리가 일어난다.
	- Duck 에서 구체적인 행동 구현도 필요 없고, 공통 swim, fly 들은 재사용도 가능해진다.
	- "청둥오리" 가 "꽥" 소리를 낸다고 구현하지 말고, "소리내어 운다" 라는 상위 개념을 이용하도록 구현해라. - 다형성

```java
Dog dog = new Dog();
dog.bark();
```
- 이런 구현 방식이면, 2줄 코드를 이용하는 영역은 강아지에 온전히 잡아먹히게 된다.
- `Dog` class 변화가 생기면 영향을 받음.

```java
Animal animal = new Dog();
animal.makeSound();
```
- `Dog` 의 변화로부터 비교적 자유로워 졌다.
- 조금만 더 자유롭게 해볼까?

```java
Animal animal = getAnimal();
animal.makeSound();
```

## 다른 클래스에 위임
- 자주 변경되는 영역을 인터페이스로 분리하고, 구현 클래스에 위임한다.
	- 이를 통해 위임을 한 클래스는 변경으로 부터 자유로워진다.
	- 공통으로 위임된 구현 클래스들 덕분에 관리(유지보수) 또한 편해진다.
- 생성자, setter 등을 통해 동적 변경 또한 가능하다. 혹은 함수의 파라미터로도.