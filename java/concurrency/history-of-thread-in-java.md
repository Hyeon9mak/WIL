### 진짜로 새롭게 알게 된 내용

- 자바는 애초에 동시성을 염두에 두고 설계 되었다. 다중 스레드를 언어 자체적으로 지원하는 최초의 언어중 하나.
  - 기본적인 동기화 및 스레드 관리가 시작, Java 5 java.util.concurrent 도입과 동시에 Executor, lock 같은 새로운 기능들이 추가되고, Java 7 에서 Fork/Join 도입으로 다중 코어 프로세서를 위한 동시성 성능 활용 시작. 최근에는 Project Loom (가상 스레드) 로 발전 중.
  - 긍까 원래는 프로세스당 처리 1개가 기본. 자바는 거기서 스레드라는 개념으로 분리해서 동시성 효율을 올렸고, 이제 가상 스레드(경량 스레드) 개념을 하나 더해서 스위칭 효율까지 UP 했다는거구만.
  - 가상 스레드가 생각 이상으로 코루틴과 유사함. 경량 스레드 모델은 특히 100% 일치.
- 예외 스택 트레이스, 디버깅 모두 스레드로 만들어졌다는게 인상적이었음
  - 메인 스레드 따라다니면서 메서드 호출내역 모두 적재하기 ㅇㅋ.
  - 디버거도 proxy 처럼 메서드 수행 전에 찍는거구나 생각하면 ㅇㅋ..
- 논리적으로 스레드 수가 많아지면 처리량도 늘어나겠으나 현실적인 문제
  - CPU context 스위칭 비용
  - 물리적인 메모리 한계로 인한 페이징 발생
  - JVM OOM 도 발생할 수 있음
  - 게다가 JNI 를 통한 물리 스레드랑 1:1 매핑이라 OS 스레드 개수에도 영향을 바로 받음
- 기본적으로 스레드를 직접 다루는 행위는 매니징을 해주지 않는다.
  - 스레드가 막 생기면 OOM 발생 위험
- 스레드 매니징을 위해 Executor FW 를 사용함.
  - ThreadPool 을 만들어서 Thread 관리
  - ThreadPool 재활용을 통한 생산비용, 스위칭 비용 감소
  - 여전히 최종적 Blocking(Future.get()) 은 존재함.
- Executor FW 는 고유의 스케줄링 알고리즘을 통해 각 코어마다 비슷한 류의 스레드를 우선 전달 받음
  - OS 메모리에서 널리널리 활용되는 특성인 그 “지역성”을 활용하기 위해서.
  - 코어 내부 L1,2 수준의 캐시를 활용하기 위해서.
  - 잠깐 스케줄링을 돌리는게 L1,2 캐시를 MISS 내고 다시 불러오는 것 보다 훨씬 더 낫다.
- Executor FW 의 스레드들은 작업(Task)큐를 Pool 하나가 갖고 있는게 아니라 스레드 마다 갖고 있음 (Fork/Join Pool 의 특성)
  - 지 작업큐가 비어있으면 다른 스레드 큐에 밀려있는 작업 훔쳐감
  - 이를 통해 최대한 idle 한 상태의 스레드가 남지 않도록함.
- Executor FW 에 표현식을 더해준게 CompetableFeature
  - stream 처럼 체이닝 맛있잖아.
  - 최종 blocking 은 여전히 쩔수지만, 체이닝 구간 동안엔 non-blocking 맛있게 말 수 있음.
  - 메인스레드에서 → 분화 스레드
- 비동기 프로그래밍은 성능적 이점을 누리는 방법을 넘어서, 사실상 완전히 새로운 아키텍처를 채택하는거라고 볼 수 있다.
  - 코드를 읽고 다루는 방법이 완전히 바뀌기 때문에, 개인과 팀 단위의 많은 연습을 필요로한다.
- 최종적 blocking(get)을 회피하기 위해 반응형(React) 프로그래밍을 도입할 수도 있지만
  - 난이도가 높은 편이고 대부분의 도메인에서는 이정도 수준의 공학적 지식을 필요로 하지 않는다.
  - 대부분의 도메인이 갖고 있는 문제의 특성과 반응형 프로그램의 패러다임이 일치하지 않는다.
- 기존 멀티 스레드는 I/O 가 발생하면 스레드 단위로 블락이 발생한다.
  - 가상 스레드에서는 가상 스레드가 작업을 수행하는 동안 케리어 스레드(플랫폼 스레드)가 제어권을 넘겨받고 다음 일을 하러 간다.

### 어려웠거나 궁금했던 점

- 언어 자체 스레드를 활용해서 OS 에 의존하지 않는 동시성 기능 제공
  - 이라곤 했지만 사실 일반적인 멀티 스레드에서는 JNI(Java Native Interface)를 통과해서 OS 레벨의 스레드에 매핑시켜서 사용하긴하지. OS 에 의존하지 않는다는 건 프로세스로 단위로 의존하지 않는다는 뜻인듯?
  - 스레드를 생성하고 죽이는 것까지를 관리라고 볼 수 있는데, Java 는 그 스레드를 만들고 죽이는 걸 OS 에게 직접 신청하는게 아니라, 셀프로 JVM 내에서 만들고 죽일 수 있어서 OS 에 의존하지 않는다고 한건가 싶기도.
  - 윈도우, 리눅스에 따라 달라지지 않은 일관된. 이건갑다.
- 프로파일러와 스레드
  - 예외 스택 트레이스, 디버거처럼 프록시하는 느낌으로 동작하려나? 구현 원리가 궁금했음.
- `Fork/Join Pool simplifies the process of sending tasks to it.`
  - 뭘 보내는거? Task 를 Pool 에서 Thread 에게 보내는건가?
  - 어떤 스레드에게 어떤 식으로 나눌지 까지도 섹시하게.
  - 특정 스레드를 지정하거나 하는게 아니라 알아서 idle 스레드 찾아서 알잘딱깔센 ㅇㅋㅇㅋ.

### 업무와 관련된 내용

- 스레드는 HW + OS 의 영향을 받는다.
  - 반대로 말하면 잘 다루면 인프라 규모를 축소시켜 비용 감소 시킬 수 있겠다.
  - 멀티 스레드 막 다루는 곳 있으면 성능 테스트 해보면서 체크해보면 좋겠네.

### 추가로 이야기 하고 싶은 내용

- 가상 스레드가 갖고 있는 코어 컨셉이 코루틴과 매우 유사함
  - 쿼리 개수 측정 라이브러리 조금만 더 손보면 가상 스레드 활용 환경에도 대응해줄 수 있겠는데?
  - 가상 스레드도 결국 내부적으로 코루틴이랑 똑같이 ThreadLocal 을 래핑한 무언가 객체 들고 다니면서 이전 케리어 스레드의 컨텍스트 복구 시키면서 작업 수행할거 아녀~
  - 
