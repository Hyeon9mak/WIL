### 진짜로 새롭게 알게 된 내용

- 워커 스레드
    - 워커 스레드는 Thread 인터페이스의 상속체(구현체?)
    - 워커 스레드는 어딘가의 Group 에 무조건 속한다.
        - 가장 최상단의 워커 스레드 기준에서는 그룹 == Pool 이 되는듯?
    - Pool 이 갖고 있는 Queue 를 호출하여 Task 를 빼내어 실행.
    - 동작 다하거나 끝나면 interrupt 호출하여 종료.
- 스레드 풀
    - SimpleThreadPool 기준으로, submit 을 통해 워커 스레드들이 가져갈 Task 를 Queue 에 등록해둔다.
    - shutdown 하면 전체 강제 종료, close 하면 기다려주면서 천천히 종료
- Executors
    - corePoolSize: coreThreadTimeOut 이 설정되지 않았다면, 스레드들은 설정값에 따라 idle 상태여도 값만큼 유지시켜준다.
    - keepAliveTime: Pool 에 idle thread 가 제한량보다 많아질 경우, 값만큼 기다려주다가 죽임.
    - 필요에 따라 여러가지 설정을 해본다.
        - corePoolSize 와 maximumPoolSize 를 맞춰서 고정 풀처럼 활용 가능.
        - Pool 은 결국 적당수를 미리 만들어놓고 꺼내어 쓰는게 핵심이니까 잘…
        - 결국 비즈니스 상황에 걸맞게 적절한 성능 테스트가 필요해보임.
        - CPU 런타임에 영향을 자주 받는 경우?
            - CPU 코어 수와 스레드 수를 맞춘다. CPU 코어 전체에서 작업을 동시에 끝냈을 때 나머지 스레드들이 바로 얻어가서 작업 수행
        - I/O 런타임에 영향을 자주 받는 경우?
            - idle thread 를 많이 만들어서 CPU 가 가능하면 놀지 않도록.
- 고정 스레드 풀
    - 예측 가능한 수준의 트래픽 처리에 용이. 또는 뒷단의 유량 제어.
    - 결국 리소스 우위가 있을 때 채택하면 좋은 방식.
- 캐시 스레드 풀
    - 동적으로. 있으면 쓰고 없으면 그 때 생성
    - 대충 idle 스레드를 남겨뒀다가 특정 시간이 지나면 지우는 전략을 취할듯?
- 작업도둑 스레드
    - FJPool 와 다르게 Task 통짜 단위로 훔친다.
- FJPool
    - 작업을 트리 구조로 분할시키고, 하나씩 정복함. 그걸 목표로 디자인 되었다.
    - 미리 작업을 분할 해두어서 분할된 단위로 처리가 가능.
    - 독립적인 단위로 자르기 때문에 다른 스레드들이 서로 훔쳐가도 문제가 없음.
    - 이 구조가 아닌 상태에서 분할 정복을 시도하면 문제가 생긴다. (데드락 빠질 위험성)
        - Thread 가 고정으로 100개 일 때 Task 는 계속 분화하고, 부모 Task 는 자식 Task 의 응답을 기다리고, 자식은 새로운 Thread 를 할당 받으려고 대기하고 …
        - 완전히 독립적인 수행 단위를 갖는 FJPool 만이 문제없이 동작 가능.
    - 얘네끼리 주고 받는데 어떻게 문제가 없을까? 내부적으로 워커 스레드마다 덱을 갖고 있다.
    - 자기 작업을 꺼낼 땐 LIFO, 다른애 작업을 훔쳐올 땐 FIFO.
    - LIFO 면 기아현상은 어떻게 방지? 지들끼리 쉬지 않고 서로꺼 훔쳐(FIFO)오므로, 어지간해선 기아현상 X
    - 게다가 LIFO 특성 때문에 CPU cache 및 지역성 활용 굿
    - Task queue 관리를 위해 내부적으로 CAS(Compare And Swap)을 이용한다.
    - lock 을 얻고 값을 변경하는게 아니라, 예상값을 만들고 맞는지 비교 후 맞으면 교체, 아니면 무한 재시도.
    - 결국 FJPool 은 CPU 를 최대한 달달 볶기 위해 디자인.
        - 분할정복은 Pool 이 아닌 워커 스레드마다가 각자 진행한다.
        - Task 를 하나 꺼내어 가서 자기가 내부에서 자르는 느낌임.
        - 그래야 LIFO 의 캐싱 + 지역성 효과도 가능하면 많이 누릴 듯
    - 대신에 비동기 모드는 다르다. 재귀적인 분할정복 대신 FIFO 에 Task 를 다 담아버림.
        - 서로간의 순서 보장이 중요하기 때문에.
- Callable 과 Feature
    - Runnable 은 return Void.
    - return 값을 얻기 위해선 Callable
    - 단, Callable 은 무조건 get(block).
    - 그래서 Feature 로 래핑해서 선택적으로 get(block) 이 가능하도록 함.
- Continuation
    - 어떤 메서드에서 멈췄다, 재개한다 수준이 아니라 어떤 시점인지를 스냅샷 형태로 남김.
    - 스코프를 지정한다. 기본적으로 일시중지했다가 다시 시작할 수 있는 코드 조각이 된다.
    - 각 스레드에는 스택과 스택프레임이 있지.
        - 스택은 메서드 호출 때마다 쌓인다.
        - 일시정지시 스택 프레임에 복제하여 기록.
    - 이것도 가상 메모리와 마찬가지로, 재개시 스택 프레임의 모든걸 꺼내어 스레드 스택에 주는게 아니라 당장 필요한 것 + return barrier 만.
        - return barrier 가 호출되면 그 지정메 필요한 블록을 꺼내어 줌.
- JVM
    - 가상 스레드가 블락되는 걸 파킹(parking) 이라 부름
        - 그럼 파킹 해제는 누가해주나? JVM. JVM 의 wide read poller.
        - JVM wide read poller 는 FD map 을 갖고 있다.
        - 결국 가상스레드도 I/O 를 수행할 때 FD 를 통해 소켓파일을 만들어 열고닫고를 하게 되는데, 이걸 다 했는지 계속 모니터링(이벤트 루프) 돌리다가 발견하면 해당 소켓과 연결된 가상 스레드를 깨움.

### 어려웠거나 궁금했던 점

- FJPool 은 가상 스레드를 스케줄링한다?
    - 뭔가 스터디 때 이야기한거랑 살짝 다른데??
- 스레드풀 Shutdown 시 강제로 interrupt 시그널을 워커 스레드들에게 보내는건가?
- FJPool 스레드 수를 지정하지 않으면 실행중인 시스템에서 사용 가능한 프로세서 수로 시작한다.
    - 실제로 하드웨어 프로세서 수 그대로 적용된다.
- lock 을 얻고 값을 변경하는게 아니라, 예상값을 만들고 맞는지 비교 후 맞으면 교체, 아니면 무한 재시도.
    - 크게보면 락 아닌지 ㅋㅋㅋ..
