### 진짜로 새롭게 알게 된 내용

- 캐리어 스레드는 FJ Pool 에서 나오고, 그 덕분에 FJ Pool 이 누리는 이점을 그대로 누린다. (Pool 자체 매커니즘과 work-steal 알고리즘까지)
    - 이 때문에 케리어 스레드는 여전히 Task 를 서로 가로챈다.
    - JVM 에서 가상 스레드를 생산해서 FIFO Queue 에 넣어두고, FJPool 에 의해 스케줄링된 케리어 스레드들이 Task 별로 가상 스레드를 꺼내어 가는 방식.
      - 명확하지 않다. 내부 생성자 코드를 조금 더 까볼 것.
    - Parallel Stream  등에서 사용하는 FJPool.Common Pool 과는 완전히 독립적이므로, 가상 스레드와 엮어서 생각하면 안된다.
    - 그래서 가상 스레드 스케줄러의 병렬성은 가상 스레드 스케줄링에 사용 가능한 플랫폼 스레드의 수를 의미하게 된다.
    - 케리어 스레드는 실제 동작없이 가상 스레드를 운반하는 것에만 집중한다. (스케줄링)
- 애플리케이션을 빌드할 때 가상 스레드 병렬성 설정이 가능하다. 별도 옵션을 이용하면 됨.
    - `java -Djdk.virtualThreadScheduler.parallelism=4`
    - 코드에서도 변경 가능하긴함. `System.setProperty("jdk.virtualThreadScheduler.parallelism", “4”);`
    - 단, 무조건 애플리케이션이 본격적으로 실행되기 전 맨 초기에 설정이 진행되도록 하자.
- 가상 스레드의 탄생으로 CPU 의 동작은 아래와 같아진다.
    1. OS 스케줄러로 OS Thread 선별
    2. OS Thread 가 JNI 를 거쳐 Platform Thread 매핑
    3. Platform Thread 가 FJ Pool 에서 V Thread 를 뽑아내어 실제 프로그램 동작
- 가상 스레드는 기본적으로 데몬스레드다.
    - 메인 스레드가 가상 스레드의 동작을 기다리지 않는다는 뜻.
    - 때문에 가상 스레드의 작업을 끝까지 보장하고 싶다면 결국 `join()` 을 호출해야함.
- 기존에 Executors 를 사용하고 있었다면 가상스레드 도입시 코드를 수정할 부분이 크지 않다.
    - 특히나 스레드 생성시점 코드는 굉장히 유사함.
    - 가상 스레드의 특장점
- 가상 스레드도 결국 Thread 인터페이스 구현체 중 하나다. 인스턴스라는 뜻.
    - 본질은 케리어 스레드와 완전히 동일. 제대로 관리 안하면 OOM 가능성이 높다.
- ~~가상 스레드는 특정 케리어 스레드에 종속된다.~~
    - ~~Task 처럼 니꺼내꺼 구분없이 가져가는게 아니라 지정된 케리어 스레드에만.~~
    - ~~아마 지역성/캐시 활용을 위한거 같음.~~
- 가상 스레드는 기본 우선순위(5) 를 갖는다. (1~10)
    - 이를 개발자가 변경하려해도 의미가 없다. 왜? 데몬 스레드라서.
    - 워낙 많은 가상 스레드가 생성될 수 있다.
    - 엔터프라이즈 언어 특성상 개발자의 실수로 인한 인지하지 못한 기아현상 방지를 위한거 같음.
- `Thread::getAllStackTraces` 메서드가 가상 스레드의 트레이스도 보여주진 않는다.
    - 가상스레드껄 보고 싶다면 가상스레드 인스턴스에서 직접 StackTrace 를 호출해야함.
- 가상 스레드는 처리 속도를 목적으로 설계된게 아니다.
    - 더 높은 확작성을 목표로 설계되었다.
    - 가상 스레드를 만들어두는 등 예열시간이 충분히 필요한 것도 한몫.
    - 그래서 CPU 작업시간이 길면 사실 가상 스레드의 장점이 희석된다. (스레드가 많아도 의미가 없으니까)
    - 대신 I/O 등 외부 블락시간이 길면 효율성이 엄청 커진다.
- 처리량 = 동시성/시간 = 스레드 수 / 블락시간
    - 보통 개발자가 시간을 통제하긴 어렵다. 외부 요인이라서
    - 그럼 처리량을 높이기 위해 동시성 값을 늘려야하는데, 스레드 수를 늘려야한다.
    - 단순 스레드 수를 늘리는 것에는 물리적인 한계가 있다. 그래서 가상 스레드가 개쩌는 것이다!
- 가상 스레드는 Stack Frame 을 들고 다닌다. (운영체제에서 다루는 그 StackFrame)
    - 전통 스레드와 가상 스레드 모두 Heap 에 ThreadLocal(변수등)를 저장하는 건 동일하다. 인스턴스니까.
    - 근데 전통 스레드는 OS 스레드와 매핑되기 위해 고정 Size 연산이 필요하고, 이 연산이 병목이 된다.
    - 가상 스레드는 OS 스레드와 매핑이 필요 없기 때문에 스택 크기를 추정할 필요가 없어진다. 동적으로 공간 활용이 가능.
    - 블락 시점에 Stack Frame 를 Heap 에 복사해두고 케리어 스레드가 떠난다.
- 각 가상 스레드는 케리어 스레드의 ThreadLocal 값을 볼 수 없다.
    - 추상화 되어 있다. 온전히 자신의 작업(Task) 수행에만 집중할 수 있도록.
- 따지고 보면 가상 메모리(페이징) 기법과 매우 비슷하다는 걸 알 수 있다.
- 기존에는 get() 호출 시점(블락 지점)에 민감하다. 그러나 가상 스레드는 민감하지 않다.
    - 덕분에 코드를 더 읽기 쉽게 작성하기 좋다. 물론 최종 블락 지점은 여전히 어쩔 수 없긴 함.
- RDB 트랜잭션과 마찬가지로, 일관성을 보장할 `Scope` 개념이 존재함.
    - `Scope` 내부 비동기 동작중 하나가 실패하면 나머지를 취소처리.
- 기존에는 ThreadPool 의 스레드 최대 수에 제한을 두어 유량제어가 가능했다.
    - 가상 스레드 도입으로 그것이 불가능하므로, 결국 별도로 유량제어 키를 사용한다.
    - 보통 세마포어 풀을 만들고 그걸 이용한다.
    - 세마포어 키 획득에 실패하면 작업이 차단되겠지만, 가상 스레드는 차단에 따른 컨텍스트 스위칭 비용이 낮아 이런 방식이 괜찮다.
    - 세마포어 키 관련 클래스를 만들 때 Atomic 자료구조를 이용하는 걸 놓치지 말 것.
- 가상 스레드에 대표되는 문제점. Pinning.
    - 특정 상황에서는 가상 스레드가 블락되어도 케리어스레드가 떠나지 못하고 묶여버린다.
    - 기존 멀티 스레드와 그냥 동일한 상황이 되어버림.
    - 첫번째 Pinning. `Synchronized` 키워드 사용
    - 두번째 Pinning. 네이티브 메서드 (C, C++ 등) 또는 외부 함수(라이브러리 구현체 의미하나..)
- `Synchronized` 키워드 사용 환경에서 대처법
    - `ReentrantLock` 구현체 활용.
    - 결국 가상 스레드를 이용할 떄 내부 코드 중 `Synchronized` 가 없는지 잘 살펴봐야함.
    - 물론 꼭 고쳐야하는건 아님. 간단한 연산 정도는 당연히 ㄱㅊ.
    - 근데 블락이 길어지는 외부 통신이 포함된 경우 무조건 대체해주자.
    - 나중에 업데이트 가능성은 있는데, 아무튼 지금은 그러함.
- 네이티브는 마땅한 방법이 없다. 주의만 하자.
- 가상 스레드는 ThreadLocal 을 가능하면 직접적으로 활용하지 말아야 한다.
    - 가상 스레드 컨셉 자체가 몇 개가 생성될지 예측이 불가능함.
    - 가상 스레드도 자체적으로 부모 스레드의 ThreadLocal 을 가져간다. ← ?????
        - 플랫폼 스레드를 말하는건가?
    - 실험을 해보면 ThreadLocal 을 다루는 코드와 아닌 코드의 메모리 사용량 차이가 엄청나게 크다.
    - 반대로 말하면 가상 스레드가 ThreadLocal 을 안쓰면, 메모리를 거의 차지하지 않는다는 이야기.
    - 가능하면 ThreadLocal 말고, Scope Value 를 활용해라.
    - 가상 스레드 환경에서 ThreadLocal 을 다루고 싶다면 설계가 잘못된거 아닌지 의심해야함.
- 여러가지 모니터링 툴 많으니까 각 특성 이해하고 잘 써볼 것.
    - 보통 2가지가 문제다. Pinning 과 ThreadLocal 사용. 그니까 이 2개를 보는 모니터링 툴을 쓰면 됨.
    - `-Djdk.traceVirtualThreadLocals`: ThreadLocal 추적
    - `-Djdk.tracePinnedThreads=full`: Pinning 추적
    - `Java Flight Recoder`: 가상 스레드 디버깅 및 관찰
    - `jcmd` 유틸리티: 덤프에서 가상 스레드 정보 캡처
    - 그 외에도 등등 많음…

### 어려웠거나 궁금했던 점

- 처리량 = 동시성/시간 = 스레드 수 / 블락시간
    - 시간 값이 엄청 작을 경우 가상스레드가 단점이 되려나? 시간 값이 작아지면 CPU 타입이 더 늘어나게 되므로 가상 스레드의 장점은 희석되는데… 단점은… 예열시간 등… 있을 수도. 멀티 스레드가 나으려나.
- 가상 스레드가 들고 다니는 Stack Frame 이란 정확히 뭘까?
    - 일단 가상 스레드마다 들고 다니는 저장공간인거 같긴 한데.
    - 블락 종료 후 케리어 스레드에 다시 올라태울 때 값을 원상복구 시키기 위해서 저장해두는건가?
- RDB 트랜잭션과 마찬가지로, 일관성을 보장할 `Scope` 개념이 존재함.
    - 원래는 중간에 터지면 개발자가 일일히 수동 취소 명세했어야했나? 5단원 가보면 알겠지
- `Synchronized` 로 인한 핀닝.
    - 아마 `Synchronized` 구현 방식이 내부적으로 플랫폼(케리어)스레드를 묶는 방식이라 그런거 같음.
    - Synchroized 에서 interruped 를 먹지 않아서. 중간에 스레드를 반납 할래야 할 수가 없는거지.


### 추가로 이야기 하고 싶은 내용

- 쿼리 개수 측정 라이브러리에서 코루틴을 ThreadLocal 로 풀어냈는데… 실수한걸까.
    - Scope Value 같은게 있는지, 그걸로 대체가 가능한지 실험해봐야겠다.
