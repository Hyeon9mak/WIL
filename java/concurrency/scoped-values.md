### 진짜로 새롭게 알게 된 내용

- 가상 스레드 환경에서 ThreadLocal 은 구조적으로 메모리 누수가 발생하기 쉽다.
    - 가상 스레드는 수백만개가 생성될 수 있다. ThreadLocal 도 수백만개…
    - 부모 스레드에서 자식 스레드 분기시, 부모 스레드의 ThreadLocal 에 담긴 값도 복제한다.
        - 불필요한 것까지 일괄복제해서 메모리 낭비가 너무 심함.
    - 게다가 불변을 보장하지 않으므로 값을 함부러 사용하기 어렵고, null 도 허용함.
    - 게다가 명시적으로 제거하지 않는 한 스레드의 수명동안 살아있음.
        - 스레드가 재활용되는 경우 메모리 누수 발생.
    - 여러가지로 번거롭다.
- 결국 ThreadLocal 은 작업기간동안 ‘상태 관리’ 를 위한 것인지, 영구적인 데이터 보관소가 아님.
- ThreadLocal 도 처음부터 쓴건 아니고, 비즈니스 로직 개발에 불필요한 정보를 계속 파라미터로 달고 다니는게 짜쳐서 등장한 개념.
    - like a spring bean container
    - 요즘은 개발자가 의식하지 않아도 대부분의 경우 몰래 뒷단에서 ThreadLocal 을 다루고 있다.
- 그래서 등장한 것 - ScopedValue
    - 내부에 적재된 값은 불변.
    - 스레드끼리 공유하지 않는다. 정확하게 현재 스레드에 국한되어 데이터 공유 방지.
    - Scope 를 넘어서면 자동으로 참조가 해제된다. 메모리 누수 위험 줄어듦.
    - 사실상 ThreadLocal 과 사용법이 유사해서, 어렵지 않게 활용 가능.
- ScopedValue 주의할 점
    - runWhere 선언(ScopedValue 선언)과 task 수행시점을 분리할 순 없다. 그 즉시 발동.
    - 자식 스레드에게 Task 를 주고, 부모 스레드에서 ScopedValue 를 선언하면?
        - 어쨌거나 ScopedValue 호출 위치는 부모 스레드라, 자식 스레드에 ScopedValue 가 전달되지 않음.
        - 가상 스레드도 마찬가지.
        - 이름 그대로 Scope 를 명확히 지정해서 사용한다.
        - 정 전달하고 싶다면 자식 스레드 먼저 실행하면서 자식 스레드의 Scope 에 ScopeValue 를 지정해주면 된다.
- ScopedValue 는 값을 바꿀 순 없지만, 재바인딩은 가능하다.
    - 재바인딩은, Nested Scope 에서 같은 변수명을 사용하는 자식 Scope 에게 다른 값을 맥이는 것을 의미.
    - 자식 스코프 동작이 끝나면 원래 값으로 다시 돌아옴.

### 어려웠거나 궁금했던 점

> ScopedValue 는 암시적 메서드 매개변수 역할을 하여 각 메서드 시그니처에 명시적인 선언하지 않고도 데이터가 일련의 메서드 호출을 통해 전달될 수 있게 합니다. 
> 이는 특히 깊게 중첩된 메서드 호출이나 콜백 구조를 다룰 때 더 깔끔하고 유지 관리가 용이한 코드를 가능하게 합니다.

가상 스레드가 짧게짧게 움직이기 때문에, ThreadLocal 을 단순히 쓰는 것보다는 메모리 부담이 줄었지만, 그래도 가상 스레드 수가 절대적으로 많기 때문에 여전히 메모리 부담이 남아있기는 하다.
